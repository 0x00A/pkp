#!/usr/bin/env node

var path = require('path')
var net = require('net')
var fs = require('fs')

var hashd = require('hashd')
var crypto = require('crypto')
var prompt = require('cli-prompt')
var rimraf = require('rimraf')
var deepcopy = require('deepcopy')
var pkppackage = require(path.join(__dirname, '..', 'package.json'))
var args = require('optimist')
var argv = args.argv
var lib = require('../lib')

if (argv.help || argv.h) {
  var helpPath = path.join(__dirname, '..', 'help.txt')
  console.log(lib.nicetxt(fs.readFileSync(helpPath).toString()))
  process.exit(0)
}


var command = argv._[0]

lib.config.get(function(err, config) {
  if (err) {
    console.log(err)
    process.exit(1)
  }
  
  switch (command) {

    //
    // generate or add existing keys to the user config
    //
    case 'keys':

      if (argv._[1] === 'create') {

        var publicOut = argv['public-out'] || path.join(process.cwd(), 'public.key')
        var privateOut = argv['private-out'] || path.join(process.cwd(), 'private.key')

        console.log('Attempting to generate keys...')

        lib.keys.create(argv, function(err, keypair) {
          if (err) {
            console.log(err)
            process.exit(1)
          }

          try {
            fs.writeFileSync(publicOut, keypair.public)
            fs.writeFileSync(privateOut, keypair.private)            
          }
          catch (ex) {
            console.log(ex)
            process.exit(1)
          }
          console.log('Successfully created %s', publicOut)
          console.log('Successfully created %s', privateOut)
        })
      }
      else if (argv._[1] === 'add') {

        if (!argv['public-in'] || !argv['private-in']) {
          var err = new Error('A `public` and `private` keys required')
          console.log(err)
          process.exit(1)
        }
        lib.keys.add(argv)
        console.log('Successfully added public and private keys')
      }

    ;break

    //
    // create a certificate and publish it to a public key server
    //
    case 'publish':
      return lib.cert.publish(argv, config, function(err) {
        if (err) {
          console.log(err)
          process.exit(1)
        }
        process.exit(0)
      })
    ;break;

    //
    // verify the signatures and public keys in a certificate
    //
    case 'verify':
      return lib.cert.verify(argv, config, function(err, response) {
        if (err) {
          console.log(err)
          process.exit(1)
        }
        process.exit(0)
      })
    ;break

    //
    // create a data-certificate or add a signature 
    // to an existing certificate.
    //
    case 'sign':
      return lib.cert.sign(argv, config, function(err) {
        if (err) {
          console.log(err)
          process.exit(1)
        }
        process.exit(0)
      })
    ;break

    //
    // create a new name-certificate
    //
    case 'name':
      return lib.cert.name(argv, config, function(err) {
        if (err) {
          console.log(err)
          process.exit(1)
        }
        process.exit(0)
      })
    ;break
    //
    // prompt for fields required in the user config
    //
    case 'config':
      return lib.config.exec(function(err) {
        if (err) {
          console.log(err)
          process.exit(1)
        }
        process.exit(0)
      }) 
    ;break
  }
})
